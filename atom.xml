<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.aoip.top</id>
    <title>YangQing 的博客</title>
    <updated>2025-04-02T08:40:47.442Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.aoip.top"/>
    <link rel="self" href="https://blog.aoip.top/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://blog.aoip.top/images/avatar.png</logo>
    <icon>https://blog.aoip.top/favicon.ico</icon>
    <rights>All rights reserved 2025, YangQing 的博客</rights>
    <entry>
        <title type="html"><![CDATA[Golang Decimal 包文档阅读有感]]></title>
        <id>https://blog.aoip.top/post/golang-decimal-bao-wen-dang-yue-du-you-gan/</id>
        <link href="https://blog.aoip.top/post/golang-decimal-bao-wen-dang-yue-du-you-gan/">
        </link>
        <updated>2025-04-02T08:34:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="golang-decimal-包文档阅读有感">Golang Decimal 包文档阅读有感</h1>
<p>信息来源：<a href="https://v2ex.com/t/1122800">在 Go 项目里，涉及到金额计算，大家一般用什么方式？ - V2EX</a></p>
<p>官方文档：<a href="https://pkg.go.dev/github.com/shopspring/decimal#section-readme">decimal - Go Playground</a></p>
<p>今天看到一篇提问 Go 项目里一般用什么方式计算金钱的文章，下面的回答中提到了他们生产环境使用的是<code>deciaml</code>包，于是跟随提供的地址阅读了对应的官方文档。</p>
<p>惊奇于文档中几个例子设计之巧妙、代码之简洁、揭露问题之深刻，遂有感而发写下这篇文章，记录学到的知识。</p>
<p>当然原来的文章里面也提出了其他的计算方案，比如直接以分为单位（辅币单位）来存储数据等，同样值得学习。</p>
<h3 id="问题一为什么不直接使用-float64">问题一：为什么不直接使用 float64？</h3>
<p>文档提供了如下代码作为例子：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var n float64 = 0
	for i := 0; i &lt; 1000; i++ {
		n += .01
	}
	fmt.Println(n)
}
</code></pre>
<p>运行后实际给出的结果是<code>9.999999999999831</code>，我当场用Python执行了一遍这个逻辑，得到了同样的结果。</p>
<p>之前虽然知道二进制表示的小数会有误差，但一直不知道怎么写一个简单的例子来表示这种情况，现在终于学习到了。</p>
<p>当然其实也有更简单的代码：</p>
<pre><code class="language-python">print(0.1 + 0.2 == 0.3)  # False
print(0.1 + 0.2)  # 0.30000000000000004
</code></pre>
<p>不过文档给出那个例子其实还有另一层考虑，也就是精度误差的积累效应，累加的越多，误差就越大。</p>
<h3 id="问题二你为什么不用-bigrat">问题二：你为什么不用 big.Rat？</h3>
<blockquote>
<p><code>big.Rat</code> 是 Go 标准库 <code>math/big</code> 提供的<strong>高精度有理数</strong>类型，用于精确表示分数（如 <code>1/3</code>），避免浮点数的精度问题</p>
</blockquote>
<p>同样，文档也给出了一个简单的例子来解释为什么不用它：</p>
<p>假设您使用 big.Rat，您有两个数字 x 和 y，都代表 1/3，您有 <code>z=1-x-y=1/3</code>。如果你把每个数字都打印出来，字符串输出必须在某个地方停止（为了简单起见，我们假设它在小数点后 3 位停止），所以你会得到 0.333、0.333 和 0.333。但另外的 0.001 去哪了？</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;
import &quot;math/big&quot;

func main() {
	z, _ := new(big.Rat).SetString(&quot;1&quot;)
	three, _ := new(big.Rat).SetString(&quot;3&quot;)
	x := new(big.Rat).Quo(z, three)
	y := new(big.Rat).Quo(z, three)

	z = z.Sub(z, x)
	z = z.Sub(z, y)
	
	s := new(big.Rat).Add(x, y)
	s.Add(s, z)

	fmt.Println(x.FloatString(3), &quot;+&quot;) // 0.333
	fmt.Println(y.FloatString(3), &quot;+&quot;) // 0.333
	fmt.Println(z.FloatString(3))      // 0.333
	fmt.Println(&quot;=&quot;, s.FloatString(3)) // where did the other 0.001 go?
}
</code></pre>
<p>使用十进制时，打印出的字符串将精确地表示数字。因此，如果您输入 <code>x = y = 1/3</code>（精度为 3），它们实际上将等于 0.333，而当您输入 <code>z = 1 - x - y</code> 时，<code>z</code> 将等于 .334。这样就不会有漏算！</p>
<p>您仍然必须小心谨慎。如果您想将一个数字 <code>N</code> 分成三份，您就不能将 <code>N/3</code> 发送给三个不同的人。您必须选择一个发送 <code>N-（2/3*N）</code>。这个人将得到剩余的几分之一。</p>
<p>最终要的就是下面这句：</p>
<blockquote>
<p>您必须选择一个发送 <code>N-（2/3*N）</code>。这个人将得到剩余的几分之一。</p>
</blockquote>
<p>如果我在阅读这份文档之前就接到使用高精度计算的开发需求，完全不会想到<code>剩余几分之一</code>这样的写法。</p>
<h3 id="问题三为什么-api-与-bigint-的不相似">问题三：为什么 API 与 big.Int 的不相似？</h3>
<p>其实这涉及到执行效率的问题，<code>big.Int</code>的应用程序接口旨在减少内存分配的次数，以获得最佳性能。</p>
<p>但是这会造成使用上的困难，毕竟需要记忆更多的接口，而不是和往常一样使用数学运算符号来编写运算逻辑。</p>
<p>如果接口使用错了，也会影响到最终的计算结果。</p>
<p>Decimal 的行为与其他 Go 语言数值类型一致：虽然 a = b 这样的赋值不会对 b 进行深拷贝，但由于所有 Decimal 方法都会返回新的 Decimal 实例而不会修改原值，因此实际上不可能修改一个 Decimal 的值。这种机制的缺点在于会产生额外的内存分配，因此 Decimal 的性能相对较低。我的观点是，如果你选择使用 Decimal，那么相比性能而言，你可能更看重计算的准确性。</p>
<p>所以，相对于编码难度、可阅读性以及最终结果的准确性来说，付出一点性能是完全值得的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[观察者模式与 MQTT 协议应用解析：代码实现及 Socket、WebSocket 协议对比]]></title>
        <id>https://blog.aoip.top/post/guan-cha-zhe-mo-shi-yu-mqtt-xie-yi-ying-yong-jie-xi-dai-ma-shi-xian-ji-socketwebsocket-xie-yi-dui-bi/</id>
        <link href="https://blog.aoip.top/post/guan-cha-zhe-mo-shi-yu-mqtt-xie-yi-ying-yong-jie-xi-dai-ma-shi-xian-ji-socketwebsocket-xie-yi-dui-bi/">
        </link>
        <updated>2025-03-19T03:47:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="观察者模式与-mqtt-协议应用解析代码实现及-socket-websocket-协议对比">观察者模式与 MQTT 协议应用解析：代码实现及 Socket、WebSocket 协议对比</h1>
<p>观察者模式是一种行为设计模式，用于定义对象间的一对多依赖关系，使得当一个对象状态发生改变时，所有依赖它的对象都会自动收到通知并更新。其核心组件包括：</p>
<ul>
<li><strong>主题（Subject）</strong>：维护观察者列表并提供注册、注销和通知方法。</li>
<li><strong>观察者（Observer）</strong>：定义更新接口，供主题通知状态变化。</li>
</ul>
<p>MQTT协议是一种轻量级的发布/订阅消息传输协议，专为低带宽、高延迟或不稳定网络环境设计，常用于物联网场景。核心特性包括：</p>
<ul>
<li>基于TCP/IP，支持QoS（0/1/2三种消息可靠性级别）。</li>
<li>主题层级化（如<code>test/topic</code>），支持通配符<code>+</code>和<code>#</code>。</li>
<li>低资源消耗，适合嵌入式设备。</li>
</ul>
<hr>
<h3 id="代码示例">代码示例</h3>
<h4 id="非阻塞模式客户端同时发布和订阅">非阻塞模式客户端（同时发布和订阅）</h4>
<pre><code class="language-python"># client.py
# pip install paho-mqtt -i https://mirrors.aliyun.com/pypi/simple
import paho.mqtt.client as mqtt
import time

def on_message(client, userdata, msg):
    print(f&quot;主题: {msg.topic}, 消息: {msg.payload.decode()}&quot;)

client = mqtt.Client()
client.on_connect = lambda client, userdata, flags, rc: print(&quot;已连接&quot; if rc == 0 else f&quot;连接失败，返回码：{rc}&quot;)
client.on_message = on_message

client.connect(&quot;localhost&quot;, 1883, 60)
client.subscribe(&quot;test/topic&quot;)

client.loop_start()  # 非阻塞模式
try:
    while True:
        client.publish(&quot;test/topic&quot;, &quot;Hello from MQTT client!&quot;)
        print(&quot;消息已发送&quot;)
        time.sleep(1)
except KeyboardInterrupt:
    print(&quot;程序终止&quot;)
client.loop_stop()
</code></pre>
<h4 id="阻塞模式客户端仅发布一次后持续接收">阻塞模式客户端（仅发布一次后持续接收）</h4>
<pre><code class="language-python"># client_block.py
import paho.mqtt.client as mqtt
import time

def on_message(client, userdata, msg):
    print(f&quot;主题: {msg.topic}, 消息: {msg.payload.decode()}&quot;)

client = mqtt.Client()
client.on_connect = lambda client, userdata, flags, rc: print(&quot;已连接&quot; if rc == 0 else f&quot;连接失败，返回码：{rc}&quot;)
client.on_message = on_message

client.connect(&quot;localhost&quot;, 1883, 60)
client.subscribe(&quot;test/topic&quot;)
client.publish(&quot;test/topic&quot;, &quot;Hello from MQTT client!&quot;)

client.loop_forever()  # 阻塞模式
</code></pre>
<h4 id="仅订阅客户端">仅订阅客户端</h4>
<pre><code class="language-python"># client_subscribe.py
# pip install paho-mqtt -i https://mirrors.aliyun.com/pypi/simple
import paho.mqtt.client as mqtt
import time

def on_message(client, userdata, msg):
    print(f&quot;主题: {msg.topic}, 消息: {msg.payload.decode()}&quot;)

client = mqtt.Client()
client.on_message = on_message

client.connect(&quot;localhost&quot;, 1883, 60)
client.subscribe(&quot;test/topic&quot;)

client.loop_forever()  # 阻塞模式
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://picgo-yangqing.oss-cn-hangzhou.aliyuncs.com/wintoo/202503191151511.png" alt="" loading="lazy"></figure>
<hr>
<h3 id="socket与websocket简介">Socket与WebSocket简介</h3>
<ol>
<li>
<p><strong>Socket</strong>：</p>
<ul>
<li>基于TCP/IP协议的基础通信机制，提供点对点、双向字节流传输。</li>
<li>需自行处理连接状态和数据格式，常用于自定义协议（如游戏服务器）。</li>
</ul>
</li>
<li>
<p><strong>WebSocket</strong>：</p>
<ul>
<li>基于HTTP协议升级的全双工通信协议，支持浏览器与服务器实时交互。</li>
<li>自动维护连接状态，适用于实时应用（如在线聊天、股票行情）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="协议对比表格">协议对比表格</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Socket</th>
<th>WebSocket</th>
<th>MQTT</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>协议层次</strong></td>
<td>传输层（TCP/UDP）</td>
<td>应用层（基于HTTP）</td>
<td>应用层（基于TCP）</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>点对点</td>
<td>全双工长连接</td>
<td>发布/订阅模型</td>
</tr>
<tr>
<td><strong>通信模型</strong></td>
<td>双向字节流</td>
<td>消息帧</td>
<td>主题消息广播</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>自定义二进制或文本</td>
<td>文本或二进制消息</td>
<td>二进制（轻量级封装）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>自定义协议、低延迟</td>
<td>浏览器实时通信</td>
<td>物联网、弱网络环境</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu系统网卡配置覆写]]></title>
        <id>https://blog.aoip.top/post/ubuntu-xi-tong-wang-qia-pei-zhi-fu-xie/</id>
        <link href="https://blog.aoip.top/post/ubuntu-xi-tong-wang-qia-pei-zhi-fu-xie/">
        </link>
        <updated>2025-03-19T03:37:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="需求分析">需求分析</h3>
<p>今天需要在一台远程服务器上添加一个新的内网ip地址配置，用于向更多的网段提供服务。</p>
<p>但由于服务器不在身边，如果配置错误导致远程连接断开，那就需要打车去场地物理修改，会非常麻烦。</p>
<p>所以考虑编写一个覆写脚本，用于定时将当前可用的配置定时覆写到网卡配置中，并重启网络服务。</p>
<h3 id="代码实现">代码实现</h3>
<p>首先将当前可用的网卡配置备份到<code>/etc/netplan/01-netcfg.yaml.bak250319</code>文件中</p>
<p>然后编写下面的shell脚本<code>overwrite_net_config.sh</code>：</p>
<pre><code class="language-bash">#!/bin/bash

# 覆盖网络配置文件
sudo cp -f /etc/netplan/01-netcfg.yaml.bak250319 /etc/netplan/01-netcfg.yaml

# 应用新的网络配置
sudo netplan apply

# 单独启动指定网卡（不停止直接启动）
sudo ip link set enxac0033aa9633 up
sudo ip link set eno1 up

echo &quot;[$(date '+%Y-%m-%d %T')] 网络配置已更新并成功启动指定网卡&quot;
</code></pre>
<p>手动执行测试功能是否正常</p>
<h3 id="代码部署">代码部署</h3>
<p>使用crontab服务配置定时任务</p>
<pre><code class="language-bash">sudo crontab -e
</code></pre>
<p>填写脚本执行信息，设置每30分钟覆写一次</p>
<pre><code class="language-bash"># 覆写网络配置文件
*/30 * * * * /bin/bash /etc/netplan/overwrite_net_config.sh &gt;&gt; /home/wintoo/log/netplan-cron/overwrite_net_config.log 2&gt;&amp;1
</code></pre>
<p>一开始可以把间隔设置的短一点，测试一下配置文件是否被成功覆写，日志是否正常打印。</p>
<p>测试完成之后就可以安心的修改网络配置了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正向代理、反向代理的异同点]]></title>
        <id>https://blog.aoip.top/post/zheng-xiang-dai-li-fan-xiang-dai-li-de-yi-tong-dian/</id>
        <link href="https://blog.aoip.top/post/zheng-xiang-dai-li-fan-xiang-dai-li-de-yi-tong-dian/">
        </link>
        <updated>2025-03-12T06:35:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="对比表格">对比表格</h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>正向代理</strong></th>
<th><strong>反向代理</strong></th>
<th><strong>相同点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>客户端通过正向代理服务器访问外部资源</td>
<td>服务器通过反向代理服务器接收客户端请求</td>
<td>两者都是代理服务器，用于转发请求和响应</td>
</tr>
<tr>
<td><strong>客户端感知</strong></td>
<td>客户端知道正向代理的存在</td>
<td>客户端不知道反向代理的存在</td>
<td>两者都隐藏了真实服务器或客户端的身份</td>
</tr>
<tr>
<td><strong>服务对象</strong></td>
<td>为客户端提供服务</td>
<td>为服务器提供服务</td>
<td>两者都用于优化网络通信和安全性</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>翻墙、访问受限资源</td>
<td>负载均衡、缓存、SSL加速</td>
<td>两者都可以用于提高访问速度和安全性</td>
</tr>
<tr>
<td><strong>位置</strong></td>
<td>位于客户端和互联网之间</td>
<td>位于服务器和客户端之间</td>
<td>两者都位于客户端和服务器之间的通信路径上</td>
</tr>
<tr>
<td><strong>配置</strong></td>
<td>客户端需要配置代理服务器</td>
<td>服务器端配置反向代理</td>
<td>两者都需要在特定位置进行配置</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>隐藏客户端的真实IP地址</td>
<td>隐藏服务器的真实IP地址</td>
<td>两者都提供了一定程度的安全性</td>
</tr>
<tr>
<td><strong>访问控制</strong></td>
<td>可以限制客户端访问特定资源</td>
<td>可以限制客户端访问特定服务器资源</td>
<td>两者都可以用于访问控制</td>
</tr>
<tr>
<td><strong>缓存功能</strong></td>
<td>可以缓存外部资源以加快访问速度</td>
<td>可以缓存服务器资源以加快响应速度</td>
<td>两者都可以使用缓存功能</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结：</h3>
<ul>
<li><strong>正向代理</strong> 主要用于客户端访问外部资源，隐藏客户端的真实身份。<strong>（VPN、租房中介）</strong></li>
<li><strong>反向代理</strong> 主要用于服务器接收客户端请求，隐藏服务器的真实身份。<strong>（二房东）</strong></li>
<li>两者都用于优化网络通信、提高安全性和访问速度。</li>
</ul>
<p>1、<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</p>
<p>2、<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</p>
<p>3、<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</p>
<p>4、正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></p>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL 替换字符串功能]]></title>
        <id>https://blog.aoip.top/post/postgresql-ti-huan-zi-fu-chuan-gong-neng/</id>
        <link href="https://blog.aoip.top/post/postgresql-ti-huan-zi-fu-chuan-gong-neng/">
        </link>
        <updated>2025-02-19T09:32:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="postgresql-替换字符串功能">PostgreSQL 替换字符串功能</h1>
<p>本文档介绍了如何在 PostgreSQL 中使用 SQL 语句批量替换字符串，包括替换 JSON 字段中的字符串和替换普通字段中的字符串。</p>
<hr>
<h2 id="1-替换-json-字段中的字符串">1. 替换 JSON 字段中的字符串</h2>
<h3 id="功能描述">功能描述</h3>
<p>该 SQL 语句用于批量替换 <code>ticket</code> 表中 <code>repair_pic</code> 字段（JSON 类型）中的图片地址。</p>
<h3 id="sql-语句">SQL 语句</h3>
<pre><code class="language-sql">DO $$
DECLARE
    affected_rows INTEGER;
    iteration_count INTEGER := 1;
BEGIN
    LOOP
        WITH cte AS (
            SELECT uid
            FROM ticket
            WHERE repair_pic::text LIKE '%img.test.domain.cn/com/v2%'
            LIMIT 1000
        )
        UPDATE ticket t
        SET repair_pic = replace(t.repair_pic::text, 'img.test.domain.cn/com/v2', 'cdn.test.domain.com/image/i/imgs')::json
        FROM cte
        WHERE t.uid = cte.uid;

        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        RAISE NOTICE '第 % 次更新，本次更新 % 行', iteration_count, affected_rows;
        EXIT WHEN affected_rows = 0;

        iteration_count := iteration_count + 1;
    END LOOP;
END $$;
</code></pre>
<h3 id="关键点">关键点</h3>
<ol>
<li><strong>循环更新</strong>：
<ul>
<li>每次更新最多 1000 行，直到没有需要更新的行为止。</li>
</ul>
</li>
<li><strong>替换逻辑</strong>：
<ul>
<li>将 <code>repair_pic</code> 字段中的 <code>img.test.domain.cn/com/v2</code> 替换为 <code>cdn.test.domain.com/image/i/imgs</code>。</li>
</ul>
</li>
<li><strong>日志输出</strong>：
<ul>
<li>使用 <code>RAISE NOTICE</code> 输出每次更新的行数。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-替换普通字段中的字符串">2. 替换普通字段中的字符串</h2>
<h3 id="功能描述-2">功能描述</h3>
<p>该 SQL 语句用于批量替换 <code>ticket</code> 表中 <code>cover</code> 字段（字符串类型）中的图片地址。</p>
<h3 id="sql-语句-2">SQL 语句</h3>
<pre><code class="language-sql">DO $$
DECLARE
    affected_rows INTEGER;
BEGIN
    LOOP
        WITH cte AS (
            SELECT uid
            FROM ticket
            WHERE cover LIKE 'https://cdn.test.domain.com/image/i/imgs/thum/%'
            LIMIT 5000
        )
        UPDATE ticket t
        SET cover = replace(cover, 'https://cdn.test.domain.com/image/i/imgs/thum/', 'https://cdn.test.domain.com/image/i/imgs/')
        FROM cte
        WHERE t.uid = cte.uid;

        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        RAISE NOTICE '本次更新 % 行', affected_rows;
        EXIT WHEN affected_rows = 0;
    END LOOP;
END $$;
</code></pre>
<h3 id="关键点-2">关键点</h3>
<ol>
<li><strong>循环更新</strong>：
<ul>
<li>每次更新最多 5000 行，直到没有需要更新的行为止。</li>
</ul>
</li>
<li><strong>替换逻辑</strong>：
<ul>
<li>将 <code>cover</code> 字段中的 <code>https://cdn.test.domain.com/image/i/imgs/thum/</code> 替换为 <code>https://cdn.test.domain.com/image/i/imgs/</code>。</li>
</ul>
</li>
<li><strong>日志输出</strong>：
<ul>
<li>使用 <code>RAISE NOTICE</code> 输出每次更新的行数。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-总结">3. 总结</h2>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>字段类型</strong></th>
<th><strong>替换逻辑</strong></th>
<th><strong>更新方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>替换 JSON 字段中的字符串</td>
<td>JSON</td>
<td><code>img.test.domain.cn/com/v2</code> → <code>cdn.test.domain.com/image/i/imgs</code></td>
<td>每次最多更新 1000 行</td>
</tr>
<tr>
<td>替换普通字段中的字符串</td>
<td>字符串</td>
<td><code>https://cdn.test.domain.com/image/i/imgs/thum/</code> → <code>https://cdn.test.domain.com/image/i/imgs/</code></td>
<td>每次最多更新 5000 行</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4-注意事项">4. 注意事项</h2>
<ol>
<li><strong>性能优化</strong>：
<ul>
<li>通过 <code>LIMIT</code> 限制每次更新的行数，避免一次性更新过多数据导致性能问题。</li>
</ul>
</li>
<li><strong>日志监控</strong>：
<ul>
<li>使用 <code>RAISE NOTICE</code> 输出更新日志，便于监控更新进度。</li>
</ul>
</li>
<li><strong>字段类型</strong>：
<ul>
<li>替换 JSON 字段时，需要先将字段转换为字符串，替换后再转换回 JSON。</li>
</ul>
</li>
</ol>
<hr>
<p>希望这份笔记对你有帮助！如果有其他问题，欢迎随时提问。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 中 min 函数的 key 参数用法]]></title>
        <id>https://blog.aoip.top/post/python-zhong-min-han-shu-de-key-can-shu-yong-fa/</id>
        <link href="https://blog.aoip.top/post/python-zhong-min-han-shu-de-key-can-shu-yong-fa/">
        </link>
        <updated>2025-02-05T09:05:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-min-函数简介">1. <code>min</code> 函数简介</h4>
<p><code>min</code> 函数用于返回可迭代对象中的最小值。它可以接受一个可选的 <code>key</code> 参数，用于指定比较的标准。</p>
<h4 id="2-key-参数的作用">2. <code>key</code> 参数的作用</h4>
<ul>
<li><code>key</code> 参数是一个函数，用于从每个元素中提取用于比较的值。</li>
<li>如果不提供 <code>key</code> 参数，<code>min</code> 函数将直接比较元素本身。</li>
</ul>
<h4 id="3-在字典中的应用">3. 在字典中的应用</h4>
<p>当我们处理字典时，<code>min</code> 函数可以用于获取最小的键或值。</p>
<h5 id="示例-1比较字典的值">示例 1：比较字典的值</h5>
<p>如果我们想找到字典中值最小的键，可以使用 <code>dict.get</code> 作为 <code>key</code> 函数：</p>
<pre><code class="language-python">street_dict = {'roads_name': 10, 'first_name': 5, 'second_name': 7}

# 找到值最小的键
min_key = min(street_dict, key=street_dict.get)

# 找到对应的值
min_value = street_dict[min_key]

print(&quot;值最小的键是:&quot;, min_key)
print(&quot;对应的值是:&quot;, min_value)
</code></pre>
<p>在这个示例中：</p>
<ul>
<li><code>min_key</code> 将存储值最小的键（<code>first_name</code>）。</li>
<li><code>min_value</code> 将存储该键对应的值（<code>5</code>）。</li>
</ul>
<h5 id="示例-2比较字典的键">示例 2：比较字典的键</h5>
<p>如果我们想找到字典中最小的键，可以直接使用 <code>min</code> 函数：</p>
<pre><code class="language-python"># 找到最小的键
min_key = min(street_dict)

# 找到对应的值
min_value = street_dict[min_key]

print(&quot;最小的键是:&quot;, min_key)
print(&quot;对应的值是:&quot;, min_value)
</code></pre>
<p>在这个示例中：</p>
<ul>
<li><code>min_key</code> 将存储字典中最小的键。</li>
<li><code>min_value</code> 将存储该键对应的值。</li>
</ul>
<h4 id="4-其他注意事项">4. 其他注意事项</h4>
<ul>
<li><code>key</code> 函数可以是任何可调用对象（如函数、lambda 表达式等）。</li>
<li>如果可迭代对象为空，<code>min</code> 函数会引发 <code>ValueError</code>。</li>
<li><code>min</code> 函数可以与其他数据结构（如列表、元组等）结合使用，<code>key</code> 参数的用法相同。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置frpc自动启动]]></title>
        <id>https://blog.aoip.top/post/zi-dong/</id>
        <link href="https://blog.aoip.top/post/zi-dong/">
        </link>
        <updated>2025-01-22T02:45:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>今天在使用VMWare启动Ubuntu虚拟机的时候发现虚拟机没有网络，排查了发现虚拟机的网络适配器使用的是“桥接模式”，查了资料说使用“NAT模式”比较适配大多数情况，修改配置后果然虚拟机有网络了。</p>
<p>但是发现了一个问题，我配置在虚拟机中的frpc服务并没有在网络恢复后自动重启恢复，于是查阅解决方法，发现<code>systemd</code>本身就有重启相关的配置。</p>
<p>原先配置文件中这一块的配置是：<code>Restart=on-failure</code></p>
<p>这意味着 <code>systemd</code> 只会在服务<strong>异常退出</strong>时才会重启服务。如果服务因为网络不可用而无法启动，<code>systemd</code> 可能不会将其视为“失败”，因此不会自动重启。</p>
<p>所以解决方案就是将其修改为<code>Restart=always</code>，这样无论服务因何原因退出（包括网络不可用），<code>systemd</code> 都会尝试重启服务。</p>
<p>并且可以设置一个等待时间，避免频繁尝试占用系统资源。</p>
<h2 id="具体解决方案">具体解决方案</h2>
<p><code>systemd</code> 提供了强大的服务管理功能，可以通过配置服务的 <code>Restart</code> 和 <code>RestartSec</code> 选项来实现自动重启。</p>
<ol>
<li>
<p>编辑 <code>frpc</code> 的 <code>systemd</code> 服务文件：</p>
<pre><code class="language-bash">sudo nano /etc/systemd/system/frpc.service
</code></pre>
</li>
<li>
<p>在 <code>[Service]</code> 部分添加以下内容：</p>
<pre><code class="language-ini">[Service]
Restart=always
RestartSec=10
</code></pre>
<ul>
<li><code>Restart=always</code>：表示无论服务因何原因退出，都会自动重启。</li>
<li><code>RestartSec=10</code>：表示每次重启前等待 10 秒。</li>
</ul>
</li>
<li>
<p>保存并退出，然后重新加载 <code>systemd</code> 配置：</p>
<pre><code class="language-bash">sudo systemctl daemon-reload
</code></pre>
</li>
<li>
<p>重启 <code>frpc</code> 服务以应用更改：</p>
<pre><code class="language-bash">sudo systemctl restart frpc
</code></pre>
</li>
</ol>
<p>这样，<code>frpc</code> 服务会在网络恢复后自动重启。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VMWare 给 Ubuntu 扩容数据盘]]></title>
        <id>https://blog.aoip.top/post/vmware-gei-ubuntu-kuo-rong-shu-ju-pan/</id>
        <link href="https://blog.aoip.top/post/vmware-gei-ubuntu-kuo-rong-shu-ju-pan/">
        </link>
        <updated>2025-01-21T09:26:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="需求">需求</h2>
<p>已经将一块1TB的虚拟硬盘添加给Ubuntu虚拟机，现在需要将其扩容到2TB。</p>
<h2 id="vmware-软件操作">VMWare 软件操作</h2>
<p>右键需要扩容的虚拟机，选择“设置”：</p>
<figure data-type="image" tabindex="1"><img src="https://picgo-yangqing.oss-cn-hangzhou.aliyuncs.com/wintoo/202501211719139.png" alt="image-20250121171931101" loading="lazy"></figure>
<p>按照下面的步骤修改磁盘容量：</p>
<figure data-type="image" tabindex="2"><img src="https://picgo-yangqing.oss-cn-hangzhou.aliyuncs.com/wintoo/202501211709116.png" alt="image-20250121170915974" loading="lazy"></figure>
<p>等待扩展完成后的提示：<br>
<img src="https://picgo-yangqing.oss-cn-hangzhou.aliyuncs.com/wintoo/202501211718113.png" alt="image-20250121171849051" loading="lazy"></p>
<h2 id="ubuntu-系统内部操作">Ubuntu 系统内部操作</h2>
<h3 id="1-确认磁盘容量变化">1. 确认磁盘容量变化</h3>
<p>首先，检查磁盘是否已经识别到新的容量。</p>
<pre><code class="language-bash">lsblk
</code></pre>
<p>或者使用 <code>fdisk</code> 查看磁盘信息：</p>
<pre><code class="language-bash">sudo fdisk -l /dev/sdX
</code></pre>
<p>（将 <code>/dev/sdX</code> 替换为你的磁盘设备名称，如 <code>/dev/sdb</code>）</p>
<p>应该会看到磁盘的总容量已经变为 2TB，但分区可能仍然是 1TB。</p>
<h3 id="2-调整分区大小">2. 调整分区大小</h3>
<p>如果磁盘的分区没有自动扩展到新的空间，需要手动调整分区大小。</p>
<h4 id="使用-parted-调整分区">使用 <code>parted</code> 调整分区</h4>
<ol>
<li>
<p>打开 <code>parted</code>：</p>
<pre><code class="language-bash">sudo parted /dev/sdX
</code></pre>
</li>
<li>
<p>查看分区信息：</p>
<pre><code class="language-bash">(parted) print
</code></pre>
<p>记录下需要调整的分区号（例如 <code>1</code>）。</p>
</li>
<li>
<p>调整分区大小：</p>
<pre><code class="language-bash">(parted) resizepart 1
</code></pre>
<p>输入新的结束位置（例如 <code>100%</code> 表示使用所有可用空间）。</p>
</li>
<li>
<p>退出 <code>parted</code>：</p>
<pre><code class="language-bash">(parted) quit
</code></pre>
</li>
</ol>
<h3 id="3-调整文件系统大小">3. 调整文件系统大小</h3>
<p>调整分区后，文件系统可能仍然只占用原来的 1TB 空间，需要使用工具扩展文件系统。</p>
<h4 id="对于-ext4-文件系统">对于 ext4 文件系统</h4>
<p>使用 <code>resize2fs</code> 扩展文件系统：</p>
<pre><code class="language-bash">sudo resize2fs /dev/sdX1
</code></pre>
<p>（将 <code>/dev/sdX1</code> 替换为你的分区名称）</p>
<h4 id="对于其他文件系统">对于其他文件系统</h4>
<ul>
<li>
<p><strong>XFS</strong>：使用 <code>xfs_growfs</code>：</p>
<pre><code class="language-bash">sudo xfs_growfs /mount/point
</code></pre>
</li>
<li>
<p><strong>Btrfs</strong>：使用 <code>btrfs filesystem resize</code>：</p>
<pre><code class="language-bash">sudo btrfs filesystem resize max /mount/point
</code></pre>
</li>
</ul>
<h3 id="4-验证调整结果">4. 验证调整结果</h3>
<p>使用以下命令确认分区和文件系统已正确扩展：</p>
<pre><code class="language-bash">lsblk
df -h
</code></pre>
<p>你应该会看到分区和文件系统的大小已经变为 2TB。</p>
<h3 id="5-注意事项">5. 注意事项</h3>
<ul>
<li><strong>数据备份</strong>：在调整分区和文件系统之前，建议备份重要数据，以防操作失误导致数据丢失。</li>
<li><strong>LVM 分区</strong>：如果你的磁盘使用了 LVM，调整步骤会有所不同，需要扩展物理卷（PV）、逻辑卷（LV）和文件系统。</li>
<li><strong>虚拟机快照</strong>：在操作前可以创建一个虚拟机快照，以便在出现问题时快速恢复。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[load_dotenv 使用笔记]]></title>
        <id>https://blog.aoip.top/post/load_dotenv-shi-yong-bi-ji/</id>
        <link href="https://blog.aoip.top/post/load_dotenv-shi-yong-bi-ji/">
        </link>
        <updated>2025-01-07T09:48:47.000Z</updated>
        <content type="html"><![CDATA[<p><code>load_dotenv</code> 是一个 Python 库，用于从 <code>.env</code> 文件中加载环境变量。它通常用于管理应用程序的配置，避免将敏感信息（如 API 密钥、数据库密码等）硬编码在代码中。</p>
<h2 id="安装">安装</h2>
<p>首先，你需要安装 <code>python-dotenv</code> 包：</p>
<pre><code class="language-bash">pip install python-dotenv
</code></pre>
<h2 id="基本用法">基本用法</h2>
<ol>
<li>
<p><strong>创建 <code>.env</code> 文件</strong></p>
<p>在项目的根目录下创建一个 <code>.env</code> 文件，并在其中定义环境变量。例如：</p>
<pre><code class="language-plaintext">DATABASE_URL=postgres://user:password@localhost:5432/mydatabase
SECRET_KEY=mysecretkey
DEBUG=True
</code></pre>
</li>
<li>
<p><strong>加载 <code>.env</code> 文件</strong></p>
<p>在你的 Python 代码中，使用 <code>load_dotenv</code> 函数来加载 <code>.env</code> 文件中的环境变量：</p>
<pre><code class="language-python">from dotenv import load_dotenv
import os

# 加载 .env 文件中的环境变量
load_dotenv()

# 访问环境变量
database_url = os.getenv('DATABASE_URL')
secret_key = os.getenv('SECRET_KEY')
debug = os.getenv('DEBUG')

print(f&quot;Database URL: {database_url}&quot;)
print(f&quot;Secret Key: {secret_key}&quot;)
print(f&quot;Debug Mode: {debug}&quot;)
</code></pre>
</li>
<li>
<p><strong>运行代码</strong></p>
<p>当你运行上述代码时，<code>load_dotenv</code> 会从 <code>.env</code> 文件中加载环境变量，并通过 <code>os.getenv</code> 访问这些变量。</p>
</li>
</ol>
<h2 id="高级用法">高级用法</h2>
<ol>
<li>
<p><strong>指定 <code>.env</code> 文件路径</strong></p>
<p>如果你的 <code>.env</code> 文件不在项目的根目录下，或者你想加载其他名称的文件，可以通过 <code>dotenv_path</code> 参数指定路径：</p>
<pre><code class="language-python">load_dotenv(dotenv_path='/path/to/.env')
</code></pre>
</li>
<li>
<p><strong>覆盖现有环境变量</strong></p>
<p>默认情况下，<code>load_dotenv</code> 不会覆盖已经存在的环境变量。如果你希望 <code>.env</code> 文件中的变量覆盖现有变量，可以设置 <code>override=True</code>：</p>
<pre><code class="language-python">load_dotenv(override=True)
</code></pre>
</li>
<li>
<p><strong>使用 <code>find_dotenv</code> 自动查找 <code>.env</code> 文件</strong></p>
<p><code>find_dotenv</code> 函数可以自动查找 <code>.env</code> 文件的位置：</p>
<pre><code class="language-python">from dotenv import load_dotenv, find_dotenv

load_dotenv(find_dotenv())
</code></pre>
<blockquote>
<p><code>load_dotenv()</code> 和 <code>load_dotenv(find_dotenv())</code> 的主要区别在于如何查找和加载 <code>.env</code> 文件。以下是两者的详细对比：</p>
<hr>
<ol>
<li>
<p><strong><code>load_dotenv()</code></strong></p>
<ul>
<li><strong>默认行为</strong>：<code>load_dotenv()</code> 会尝试在当前工作目录（即运行 Python 脚本的目录）中查找 <code>.env</code> 文件并加载它。</li>
<li><strong>优点</strong>：简单直接，适合 <code>.env</code> 文件位于项目根目录且运行脚本时工作目录正确的情况。</li>
<li><strong>缺点</strong>：如果 <code>.env</code> 文件不在当前工作目录中，或者脚本是从其他目录运行的，<code>load_dotenv()</code> 可能无法找到 <code>.env</code> 文件。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-python">from dotenv import load_dotenv
import os

load_dotenv()  # 默认从当前工作目录加载 .env 文件

print(os.getenv('MY_VAR'))
</code></pre>
</li>
</ol>
<hr>
<ol start="2">
<li>
<p><strong><code>load_dotenv(find_dotenv())</code></strong></p>
<ul>
<li><strong><code>find_dotenv()</code> 的作用</strong>：<code>find_dotenv()</code> 会递归地向上搜索目录树，查找 <code>.env</code> 文件的位置。它会从当前目录开始，逐级向上查找，直到找到 <code>.env</code> 文件或到达文件系统的根目录。</li>
<li><strong>优点</strong>：
<ul>
<li>更灵活：即使脚本是从子目录运行的，<code>find_dotenv()</code> 也能找到 <code>.env</code> 文件。</li>
<li>更健壮：适合项目结构复杂或脚本从不同目录运行的情况。</li>
</ul>
</li>
<li><strong>缺点</strong>：稍微复杂一些，需要额外调用 <code>find_dotenv()</code>。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<pre><code class="language-python">from dotenv import load_dotenv, find_dotenv
import os

load_dotenv(find_dotenv())  # 自动查找 .env 文件并加载

print(os.getenv('MY_VAR'))
</code></pre>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>总结</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>load_dotenv()</code></td>
<td>简单项目，<code>.env</code> 文件位于项目根目录且脚本从根目录运行</td>
<td>简单直接</td>
<td>依赖当前工作目录</td>
</tr>
<tr>
<td><code>load_dotenv(find_dotenv())</code></td>
<td>复杂项目，<code>.env</code> 文件可能位于上级目录，或脚本从子目录运行</td>
<td>更健壮，自动查找 <code>.env</code> 文件</td>
<td>稍微复杂</td>
</tr>
</tbody>
</table>
<p>推荐在大多数情况下使用 <code>load_dotenv(find_dotenv())</code>，因为它更健壮且适应性更强。</p>
</blockquote>
</li>
<li>
<p><strong>在 Flask 中使用 <code>load_dotenv</code></strong></p>
<p>在 Flask 应用中，通常会在应用启动时加载 <code>.env</code> 文件：</p>
<pre><code class="language-python">from flask import Flask
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')

@app.route('/')
def hello():
    return &quot;Hello, World!&quot;

if __name__ == '__main__':
    app.run(debug=os.getenv('DEBUG') == 'True')
</code></pre>
</li>
</ol>
<h2 id="样例代码">样例代码</h2>
<p>以下是一个完整的样例代码，展示了如何使用 <code>load_dotenv</code> 加载环境变量并在 Flask 应用中使用它们：</p>
<pre><code class="language-python">from flask import Flask
from dotenv import load_dotenv
import os

# 加载 .env 文件中的环境变量
load_dotenv()

app = Flask(__name__)

# 从环境变量中获取配置
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
app.config['DEBUG'] = os.getenv('DEBUG') == 'True'

@app.route('/')
def hello():
    return &quot;Hello, World!&quot;

if __name__ == '__main__':
    app.run(debug=app.config['DEBUG'])
</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><code>load_dotenv</code> 是一个非常有用的工具，可以帮助你管理应用程序的配置。</li>
<li>通过 <code>.env</code> 文件，你可以将敏感信息与代码分离，提高安全性。</li>
<li>你可以通过 <code>dotenv_path</code> 参数指定 <code>.env</code> 文件的路径，或者使用 <code>find_dotenv</code> 自动查找文件。</li>
<li>在 Flask 等框架中，<code>load_dotenv</code> 可以帮助你轻松加载配置。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义APIRoute实现大文件上传优先校验时效Token]]></title>
        <id>https://blog.aoip.top/post/chong-xie-apiroute-shi-xian-da-wen-jian-shang-chuan-you-xian-xiao-yan-shi-xiao-token/</id>
        <link href="https://blog.aoip.top/post/chong-xie-apiroute-shi-xian-da-wen-jian-shang-chuan-you-xian-xiao-yan-shi-xiao-token/">
        </link>
        <updated>2025-01-02T12:10:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义apiroute实现大文件上传优先校验时效token">自定义APIRoute实现大文件上传优先校验时效Token</h1>
<h2 id="业务介绍">业务介绍</h2>
<p>公司中的文件上传服务是我编写和维护的，今天同事在上传大文件的时候发现Nginx报错，超过允许的最大容量。</p>
<p>查看Nginx配置文件发现 <code>client_max_body_size</code>参数被设置为了 <code>500M</code>，于是修改成 <code>2G</code>。</p>
<p>过了一会同事发消息说上传接口报错了，返回信息如下：</p>
<pre><code class="language-json">{
    &quot;code&quot;: 20206,
    &quot;message&quot;: &quot;The File upload timeout&quot;,
    &quot;response&quot;: {}
}
</code></pre>
<p>出现这个报错是因为上传的时候使用了已经失效的Token，但是程序上传都是当场根据时间戳生成的Token，文件服务中设置的Token失效时间是5分钟，按理说不可能会超时的。</p>
<p>在确认了同事服务器的时区以及生成的时间戳都正常之后我想到了另一种可能：<strong>文件服务接口接收大文件的时间超过了5分钟。</strong></p>
<h2 id="问题分析">问题分析</h2>
<p>通过查阅文件服务接口代码发现，Token信息是存放在Headers里面的，<strong>但是用于校验Token的时间戳以及随机码是存放在Body里面的。</strong></p>
<p>Body同时也是存放文件数据的地方。</p>
<p>而且进行Token校验的地方是业务逻辑函数上面的装饰器。</p>
<p>这就造成接口想要验证Token是否有效，<strong>就需要等待Body的数据全部上传完成才行。</strong></p>
<p><strong>路由代码：</strong></p>
<pre><code class="language-python">    @router.post(&quot;/file/add_device_file&quot;, summary=&quot;添加设备文件接口&quot;)
    async def add_device_file(
        self,
        request: Request,
        form_data = Form(..., description=&quot;文件对象&quot;),  # 下面的数据都是从body获取的form-data格式的数据
        time: int = Form(..., description=&quot;时间戳&quot;),
        num: int = Form(..., description=&quot;随机数&quot;),
        app_key: str = Form(..., description=&quot;平台信息&quot;),
    ) -&gt; UploadFileResponse:
        &quot;&quot;&quot;文件添加接口(设备文件上传)&quot;&quot;&quot;
        data = {
            &quot;request&quot;: request,
            &quot;file&quot;: form_data.file,
            &quot;name&quot;: form_data.filename,
            &quot;size&quot;: form_data.size,
            &quot;time&quot;: time,
            &quot;num&quot;: num,
            &quot;app_key&quot;: app_key,
        }
        return await add_device_file_ctrl(data)
</code></pre>
<p><strong>业务逻辑代码：</strong></p>
<pre><code class="language-python">@check_token
async def add_device_file_ctrl(data):
    &quot;&quot;&quot;
    上传设备文件
    &quot;&quot;&quot;
    if not data.get(&quot;name&quot;):
        raise ResponseError(
            code=ResponseCode.parameter_not_illegal,
            message=f&quot;The file not illegal&quot;,
        )
    ...
</code></pre>
<p><strong>装饰器代码：</strong></p>
<pre><code class="language-python">def check_token(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        # 测试环境关闭token验证
        # if nacos_config.minio_config.get(&quot;IS_DEBUG&quot;, 0):
        #     return await func(*args, **kwargs)

        data = args[0]
        if &quot;token&quot; not in data[&quot;request&quot;].headers:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=f&quot;The token  not illegal&quot;,
            )

        token = data[&quot;request&quot;].headers[&quot;token&quot;]

        # 将传入的时间戳、数字、密钥使用md加密后对比token
        result_str = f&quot;{data['time']}{settings.token_key}{data['num']}&quot;
        target_str = md5_encrypt(result_str)

        if target_str != token:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=f&quot;The token  not illegal&quot;,
            )

        # 使用传入的时间戳和当前时间比较
        flag = has_exceeded_time(data[&quot;time&quot;], settings.timeout_time)
        if flag:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=f&quot;The File upload timeout&quot;,
            )

        return await func(*args, **kwargs)

    return wrapper
</code></pre>
<p>从代码中可以看到，装饰器分别从 <code>headers</code>和 <code>body</code>中获取了不同的数据来完成Token校验。</p>
<p>之前上传的文件都不会超过200MB，顶天了500MB，5分钟的超时时间完全足够，但是由于最近设备端逻辑修改，上传的文件数据量猛然增加，单文件大小达到了800MB，如果上行带宽不足的话，就很容易超过5分钟的限制，于是这个隐藏的问题就被暴露出来了。</p>
<h2 id="方法1使用依赖注入的方式添加验证逻辑失败">方法1：使用依赖注入的方式添加验证逻辑（失败）</h2>
<p>FastAPI 的依赖注入机制可以在路由处理函数执行之前运行，因此可以利用它来优先校验 <code>headers</code> 中的 token，而不需要等待 <code>body</code> 完全上传。</p>
<h3 id="实现步骤">实现步骤</h3>
<ol>
<li>定义一个依赖函数，用于校验 <code>headers</code> 中的 token。</li>
<li>将该依赖函数注入到路由中。</li>
</ol>
<h3 id="示例代码">示例代码</h3>
<pre><code class="language-python">from fastapi import FastAPI, Header, HTTPException, Depends
from fastapi import UploadFile

app = FastAPI()

# 模拟 token 校验逻辑
def verify_token(authorization: str = Header(...)):
    if authorization != &quot;valid-token&quot;:
        raise HTTPException(status_code=401, detail=&quot;Invalid token&quot;)
    return True

@app.post(&quot;/upload/&quot;)
async def upload_file(
    token_valid: bool = Depends(verify_token),  # 优先校验 token
    file: UploadFile = None,  # 文件上传
):
    if not file:
        raise HTTPException(status_code=400, detail=&quot;No file uploaded&quot;)
    return {&quot;filename&quot;: file.filename, &quot;token_valid&quot;: token_valid}
</code></pre>
<h3 id="说明">说明</h3>
<ul>
<li><code>verify_token</code> 是一个依赖函数，它会优先从 <code>headers</code> 中提取 <code>Authorization</code> 并校验。</li>
<li><code>Depends(verify_token)</code> 确保在文件上传之前先执行 token 校验。</li>
<li>如果 token 校验失败，FastAPI 会直接返回 401 错误，而不会等待文件上传完成。</li>
</ul>
<h2 id="方法2在路由之前添加装饰器失败">方法2：在路由之前添加装饰器（失败）</h2>
<h3 id="新的装饰器代码">新的装饰器代码：</h3>
<pre><code class="language-python">from functools import wraps
from fastapi import Request
from your_error_module import ResponseError, ResponseCode  # 替换为实际的错误处理模块
from your_utils_module import md5_encrypt, has_exceeded_time  # 替换为实际的工具函数模块

def check_token_new_2(func):
    @wraps(func)
    async def wrapper(request: Request, *args, **kwargs):
        # 测试环境关闭token验证
        # if nacos_config.minio_config.get(&quot;IS_DEBUG&quot;, 0):
        #     return await func(request, *args, **kwargs)

        # 从 headers 中获取 token、time 和 num
        if &quot;token&quot; not in request.headers:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=&quot;The token not illegal&quot;,
            )

        token = request.headers[&quot;token&quot;]
        time = request.headers.get(&quot;time&quot;)
        num = request.headers.get(&quot;num&quot;)

        if not time or not num:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=&quot;Missing required headers: time or num&quot;,
            )

        # 将传入的时间戳、数字、密钥使用 md5 加密后对比 token
        result_str = f&quot;{time}{settings.token_key}{num}&quot;
        target_str = md5_encrypt(result_str)

        if target_str != token:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=&quot;The token not illegal&quot;,
            )

        # 使用传入的时间戳和当前时间比较
        flag = has_exceeded_time(int(time), settings.timeout_time)
        if flag:
            raise ResponseError(
                code=ResponseCode.parameter_not_illegal,
                message=&quot;The File upload timeout&quot;,
            )

        # 继续执行原始函数
        return await func(request, *args, **kwargs)

    return wrapper
</code></pre>
<h3 id="关键修改点">关键修改点</h3>
<ol>
<li><strong>直接使用 <code>Request</code> 对象</strong>：
<ul>
<li>装饰器的 <code>wrapper</code> 函数中，直接接收 <code>request: Request</code> 参数，而不是从 <code>args</code> 中提取 <code>request</code>。</li>
<li>这样可以绕过 <code>body</code> 的内容，直接从 <code>headers</code> 中获取所需的数据。</li>
</ul>
</li>
<li><strong>从 <code>headers</code> 中提取数据</strong>：
<ul>
<li>使用 <code>request.headers</code> 获取 <code>token</code>、<code>time</code> 和 <code>num</code>。</li>
<li>如果 <code>headers</code> 中缺少必要字段，直接抛出错误。</li>
</ul>
</li>
<li><strong>移除对 <code>body</code> 的依赖</strong>：
<ul>
<li>不再从 <code>args</code> 或 <code>kwargs</code> 中提取 <code>body</code> 相关的内容，确保装饰器仅处理 <code>headers</code>。</li>
</ul>
</li>
</ol>
<h3 id="使用示例">使用示例</h3>
<p>将装饰器应用到 FastAPI 的路由中：</p>
<pre><code class="language-python">from fastapi import FastAPI, Request, UploadFile, File
from your_decorator_module import check_token_new_2  # 替换为实际的装饰器模块

app = FastAPI()

@app.post(&quot;/file/add_large_device_file&quot;)
@check_token_new_2
async def add_large_device_file(request: Request, file: UploadFile = File(...)):
    # 文件上传逻辑
    return {&quot;filename&quot;: file.filename}
</code></pre>
<h2 id="方法3自定义-apiroute成功">方法3：自定义 <code>APIRoute</code>（成功！）</h2>
<p>如果你只想对某些路由生效，也可以通过自定义 <code>APIRoute</code> 来控制流程。</p>
<h3 id="示例">示例</h3>
<pre><code class="language-python">from fastapi import FastAPI, Request, HTTPException
from fastapi.routing import APIRoute

class TokenValidatedAPIRoute(APIRoute):
    def get_route_handler(self):
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request):
            # 在这里检查 headers
            token = request.headers.get(&quot;Authorization&quot;)
            if not token or token != &quot;EXPECTED_TOKEN&quot;:
                raise HTTPException(status_code=401, detail=&quot;Invalid Token&quot;)
            # 校验通过，执行原本的处理逻辑
            return await original_route_handler(request)

        return custom_route_handler

app = FastAPI()

@app.post(&quot;/upload&quot;, route_class=TokenValidatedAPIRoute)
async def upload_file(file: bytes = ...):
    return {&quot;message&quot;: &quot;Upload succeeded!&quot;}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://picgo-yangqing.oss-cn-hangzhou.aliyuncs.com/wintoo/202501022009685.png" alt="image-20250102200958924" loading="lazy"></figure>
<h3 id="优点">优点</h3>
<ul>
<li>只对指定路由应用该校验逻辑；</li>
<li>同样可以在进入路由实际处理函数之前检查 headers；</li>
<li>可以封装不同的 <code>APIRoute</code> 实例，对不同需求的路由应用不同的逻辑。</li>
</ul>
<h3 id="注意点">注意点</h3>
<ul>
<li>这种方式更“底层”，对不熟悉 Starlette/FastAPI 路由机制的同学可能不够直观。</li>
</ul>
<blockquote>
<p>需要注意的是，在当前这个文件服务里面路由接口使用的是提前定义好的 <code>APIRoute</code>对象，也就是 <code>router</code>变量，所以需要像下面这样修改代码：</p>
<p><strong>1. 在 <code>file_view.py</code>中定义新的 <code>router</code>变量：</strong></p>
<pre><code class="language-python">from fastapi import APIRouter
from minio_server.api.file.file_tools import TokenValidatedAPIRoute

new_router = APIRouter(route_class=TokenValidatedAPIRoute)
</code></pre>
<p><strong>2. 在“文件操作视图类”开头添加 <code>cvb</code>注册，并替换新接口为 <code>new_router</code>变量：</strong></p>
<pre><code class="language-python">@cbv(new_router)
class FileView:
    &quot;&quot;&quot;文件操作视图类&quot;&quot;&quot;
  
    @new_router.post(&quot;/file/add_large_device_file&quot;, summary=&quot;设备大文件上传接口&quot;)
    async def add_large_device_file(
        self,
        form_data: UploadFile = File(..., description=&quot;文件对象&quot;),
        app_key: str = Header(..., description=&quot;平台信息&quot;),
    ) -&gt; UploadFileResponse:
        &quot;&quot;&quot;文件添加接口(设备文件上传)&quot;&quot;&quot;
        # print(f&quot;token valid: {token_valid}&quot;)
        data = {
            &quot;file&quot;: form_data.file,
            &quot;name&quot;: form_data.filename,
            &quot;size&quot;: form_data.size,
            &quot;app_key&quot;: app_key,
        }
        return await add_large_device_file_ctrl(data)
</code></pre>
<p><strong>3. 在整个项目初始化的时候注册 <code>new_router</code>：</strong></p>
<pre><code class="language-python">from minio_server.api.file.file_view import new_router

app = FastAPI(lifespan=lifespan, docs_url=docs_url, redoc_url=None)

app.include_router(new_router)
</code></pre>
</blockquote>
<h2 id="方法4全局或局部中间件middleware业务其他接口需要保持原样这里不推荐">方法4：全局或局部中间件(Middleware)（业务其他接口需要保持原样，这里不推荐）</h2>
<p>中间件可以在进入具体路由之前对 <code>request.headers</code> 进行检查，如果校验失败，可以在中间件阶段直接返回响应，避免后续再去读取大文件。</p>
<h3 id="示例-2">示例</h3>
<pre><code class="language-python">from fastapi import FastAPI, Request, Response, HTTPException

app = FastAPI()

@app.middleware(&quot;http&quot;)
async def check_token_middleware(request: Request, call_next):
    # 从请求头中获取 token
    token = request.headers.get(&quot;Authorization&quot;)
    if not token or token != &quot;EXPECTED_TOKEN&quot;:
        # 如果校验失败，直接返回 401 或 403 等
        raise HTTPException(status_code=401, detail=&quot;Invalid Token&quot;)
  
    # 校验通过，继续处理请求
    response = await call_next(request)
    return response

@app.post(&quot;/upload&quot;)
async def upload_file(file: bytes = ...):
    # 到这里说明已经通过了中间件校验
    return {&quot;message&quot;: &quot;Upload succeeded!&quot;}
</code></pre>
<h3 id="优点-2">优点</h3>
<ol>
<li>可以在读取请求体（body）之前就完成对请求头的校验；</li>
<li>无需修改每个路由，适合全局通用校验；</li>
<li>逻辑清晰，易维护。</li>
</ol>
<h3 id="注意点-2">注意点</h3>
<ul>
<li>如果你的校验参数复杂，或者不同路由需要不同的校验逻辑，可以在局部中间件或其他层面做细分。</li>
</ul>
]]></content>
    </entry>
</feed>